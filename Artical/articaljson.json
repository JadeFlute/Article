[{"artical_url": "http://blog.jobbole.com/114455/", "artical_url_md5": "7d7ff91d7ad7e2d2a0d34d3c83959d6c", "title": "如何在 Linux 中找到并删除重复文件", "add_time": "2018-10-19", "tag": "IT技术-Linux", "content": ["在编辑或修改配置文件或旧文件前，我经常会把它们备份到硬盘的某个地方，因此我如果意外地改错了这些文件，我可以从备份中恢复它们。但问题是如果我忘记清理备份文件，一段时间之后，我的磁盘会被这些大量重复文件填满——我觉得要么是懒得清理这些旧文件，要么是担心可能会删掉重要文件。如果你们像我一样，在类Unix操作系统中，大量多版本的相同文件放在不同的备份目录，你可以使用下面的工具找到并删除重复文件。", "在删除重复文件的时请尽量小心。如果你不小心，也许会导致", "。我建议你在使用这些工具的时候要特别注意。", "出于本指南的目的，我将讨论下面的三个工具：", "这三个工具是自由开源的，且运行在大多数类Unix系统中。", "意即", "edundant", "ata", "（冗余数据查找），是一个通过访问目录和子目录来找出重复文件的自由开源的工具。它是基于文件内容而不是文件名来比较。Rdfind使用", "算法来区分原始文件和重复文件。如果你有两个或者更多的相同文件，Rdfind会很智能的找到原始文件并认定剩下的文件为重复文件。一旦找到副本文件，它会向你报告。你可以决定是删除还是使用", "代替它们。", "Rdfind存在于", "中。因此，在基于Arch的系统中，你可以像下面一样使用任一如", "AUR程序助手安装它。", "在Debian、Ubuntu、LinuxMint上：", "在Fedora上：", "在RHEL、CentOS上：", "一旦安装完成，仅带上目录路径运行Rdfind命令就可以扫描重复文件。", "正如你看到上面的截屏，Rdfind命令将扫描", "目录，并将结果存储到当前工作目录下一个名为", "的文件中。你可以在", "文件中看到可能是重复文件的名字。", "通过检查", "文件，你可以很容易的找到那些重复文件。如果愿意你可以手动的删除它们。", "此外，你可在不修改其他事情情况下使用", "选项找出所有重复文件，并在终端上输出汇总信息。", "一旦找到重复文件，你可以使用硬链接或符号链接代替他们。", "使用硬链接代替所有重复文件，运行：", "使用符号链接/软链接代替所有重复文件，运行：", "目录中有一些空文件，也许你想忽略他们，你可以像下面一样使用", "选项：", "如果你不再想要这些旧文件，删除重复文件，而不是使用硬链接或软链接代替它们。", "删除重复文件，就运行：", "如果你不想忽略空文件，并且和所哟重复文件一起删除。运行：", "更多细节，参照帮助部分：", "手册页：", "是另一个在指定目录以及子目录中识别和移除重复文件的命令行工具。这是一个使用C语言编写的自由开源工具。Fdupes通过对比文件大小、部分MD5签名、全部MD5签名，最后执行逐个字节对比校验来识别重复文件。", "与Rdfind工具类似，Fdupes附带非常少的选项来执行操作，如：", "Fdupes存在于大多数Linux发行版的默认仓库中。", "在ArchLinux和它的变种如Antergos、ManjaroLinux上，如下使用Pacman安装它。", "在Debian、Ubuntu、LinuxMint上:", "在Fedora上：", "在RHEL、CentOS上：", "Fdupes用法非常简单。仅运行下面的命令就可以在目录中找到重复文件，如：", "。", "我系统中的样例输出：", "你可以看到，在", "目录下有一个重复文件。它仅显示了父级目录中的重复文件。如何显示子目录中的重复文件？像下面一样，使用", "选项。", "现在你将看到", "目录以及子目录中的重复文件。", "Fdupes也可用来从多个目录中迅速查找重复文件。", "你甚至可以搜索多个目录，递归搜索其中一个目录，如下：", "上面的命令将搜索", "目录，", "目录和它的子目录中的重复文件。", "有时，你可能想要知道一个目录中重复文件的大小。你可以使用", "选项，如下：", "类似的，为了显示父目录和子目录中重复文件的大小，使用", "选项。", "我们可以在计算时分别使用", "和", "选项排除空白文件以及排除隐藏文件。", "在搜索指定目录的重复文件时，第一个命令将排除零长度文件，后面的命令将排除隐藏文件。", "汇总重复文件信息，使用", "选项。", "删除所有重复文件，使用", "选项。", "样例输出：", "这个命令将提示你保留还是删除所有其他重复文件。输入任一号码保留相应的文件，并删除剩下的文件。当使用这个选项的时候需要更加注意。如果不小心，你可能会删除原文件。", "如果你想要每次保留每个重复文件集合的第一个文件，且无提示的删除其他文件，使用", "选项（不推荐）。", "当遇到重复文件时删除它们，使用", "标志。", "关于Fdupes的更多细节，查看帮助部分和man页面。", "是另外一个查找重复文件的工具，有时我用它去掉Linux系统中不需要的重复文件并释放磁盘空间。不像另外两个工具，FSlint有GUI和CLI两种模式。因此对于新手来说它更友好。FSlint不仅仅找出重复文件，也找出坏符号链接、坏名字文件、临时文件、坏的用户ID、空目录和非精简的二进制文件等等。", "FSlint存在于", "，因此你可以使用任一AUR助手安装它。", "在Debian、Ubuntu、LinuxMint上：", "在Fedora上：", "在RHEL，CentOS上：", "一旦安装完成，从菜单或者应用程序启动器启动它。", "FSlintGUI展示如下：", "如你所见，FSlint界面友好、一目了然。在“Searchpath”栏，添加你要扫描的目录路径，点击左下角“Find”按钮查找重复文件。验证递归选项可以在目录和子目录中递归的搜索重复文件。FSlint将快速的扫描给定的目录并列出重复文件。", "从列表中选择那些要清理的重复文件，也可以选择“Save”、“Delete”、“Merge”和“Symlink”操作他们。", "在“Advancedsearchparameters”栏，你可以在搜索重复文件的时候指定排除的路径。", "FSlint提供下面的CLI工具集在你的文件系统中查找重复文件。", "所有这些工具位于", "下面。", "例如，在给定的目录中查找重复文件，运行：", "类似的，找出空目录命令是：", "获取每个工具更多细节，例如：", "，运行：", "关于FSlint的更多细节，参照帮助部分和man页。", "现在你知道在Linux中，使用三个工具来查找和删除不需要的重复文件。这三个工具中，我经常使用Rdfind。这并不意味着其他的两个工具效率低下，因为到目前为止我更喜欢Rdfind。好了，到你了。你的最喜欢哪一个工具呢？为什么？在下面的评论区留言让我们知道吧。", "就到这里吧。希望这篇文章对你有帮助。更多的好东西就要来了，敬请期待。", "谢谢！", ""], "praise": 1, "collect": 0, "front_img_url": ["http://jbcdn2.b0.upaiyun.com/2018/10/d1aa5a9343099d2decbb150c0a46356d.png"]},{"artical_url": "http://blog.jobbole.com/114458/", "artical_url_md5": "a9bd45a89752136f0978fe478eb5119f", "title": "命令行小技巧：读取文件的不同方式", "add_time": "2018-10-21", "tag": "IT技术- 1 评论 -Linux", "content": ["作为图形操作系统，Fedora的使用是令人愉快的。你可以轻松地点击完成任何任务。但你可能已经看到了，在底层还有一个强大的命令行。想要在shell下体验，只需要在Fedora系统中打开你的终端应用。这篇文章是向你展示常见的命令行使用方法的系列文章之一。", "在这部分，你将学习如何以不同的方式读取文件，如果你在系统中打开一个终端完成一些工作，你就有可能需要读取一两个文件。", "对命令行终端的用户来说，", "命令众所周知。当你", "一个文件，你很容易的把整个文件内容展示在你的屏幕上。而真正发生在底层的是文件一次读取一行，然后一行一行写入屏幕。", "假设你有一个文件，叫做", "，这个文件每行只有一个单词。为了简单起见，每行的单词就是这行的行号，就像这样：", "所以如果你", "这个文件，你就会看到如下输出：", "并没有太惊喜，不是吗？但是有个有趣的转折，只要使用", "命令，你可以从后往前", "这个文件。（请注意，Fedora对这种有争议的幽默不承担任何责任！）", "命令允许你以不同的方式装饰输出，比如，你可以输出行号：", "还有其他选项可以显示特殊字符和其他功能。要了解更多,请运行", "命令，看完之后，按", "即可退出回到shell。", "通常，文件太长会无法全部显示在屏幕上，您可能希望能够像文档一样查看它。这种情况下，可以试试", "命令：", "你可以用方向键，也可以用", "/", "来查看文件，按", "就可以退回到shell。", "实际上，还有一个", "命令，其基于老式的UNIX系统命令。如果在退回shell后仍想看到该文件的内容，则可能需要使用它。而", "命令则让你回到你离开shell之前的样子，并且清除屏幕上你看到的所有的文件内容。", "有时，你所需的输出只是文件的开头。比如，有一个非常长的文件，当你使用", "命令时，会显示这个文件所有内容，前几行的内容很容易滚动过去，导致你看不到。", "命令会帮你获取文件的前几行：", "同样，你会用", "命令来查看文件的末尾几行：", "当然，这些只是在这个领域的几个简单的命令。但它们可以让你在阅读文件时容易入手。", ""], "praise": 1, "collect": 3, "front_img_url": ["http://jbcdn2.b0.upaiyun.com/2018/10/683fc47a8ae84cd7b957dda2db9cf665.jpg"]},{"artical_url": "http://blog.jobbole.com/114461/", "artical_url_md5": "503ae7fbe22cb704c56f29af0f417fa6", "title": "一文带你了解 Vim 的起源", "add_time": "2018-10-24", "tag": "IT技术-Vim", "content": ["我最近偶然发现了一种名为IntelHEX的文件格式。据我所知，IntelHEX文件（使用", "扩展名）通过将二进制图像编码成十六进制数字行，使二进制图像不那么晦涩难懂。显然，当人们需要对微控制器进行编程或者将数据烧录进ROM时会用到这种文件。无论如何，当我第一次在Vim中打开一个HEX文件时，我发现了一些震惊的东西。至少对我来说，这种文件格式是非常深奥难懂的，但Vim已经掌握了它。HEX文件的每一行都是一条被划分为不同字段的记录——Vim已经预先将每个字段显示成不同的颜色。", "吗?我充满敬畏地发问。", "，Vim得意地回答。", "Vim无所不在且受众极其广泛，以至于其支持HEX文件也应该在预料之中。MacOS中预装了Vim，同时，Linux世界中也有很多Vim的支持者。即使那些讨厌Vim的人也对它很熟悉，因为太多的流行命令行工具默认使用Vim，不熟悉Vim的用户往往身陷其中，这已经变成了一个", "。包括Facebook在内的一些大型网站，当你按下", "键时，会向下滚动，而当你按下", "键时，会向上滚动——这意味着Vim通过数字文化传播达到了难以想象的高水准。", "然而，Vim也是谜一般的存在。例如，与人尽皆知的由Facebook开发和维护的React不同，Vim没有明显的发起人。尽管它如此常见和重要，但是似乎没有任何委员会或组织为Vim做出决策。你可以花几分钟去浏览", "，但却无法得知是谁创建了Vim或者为什么创建。如果只启动Vim不打开任何文件，你会看到Vim的启动消息，表明Vim是由”BramMoolenaar等人“开发的。但这并不能说明什么，BramMoolenaar到底是谁，他的神秘同伙又是谁？", "当我们求索上述问题的时候，也许更重要的是，为什么退出Vim需要输入", "？当然，这是一个“写”操作，然后是一个“退出”操作，但这不是一个特别容易直观理解的约定。谁决定了复制文本应该被称为“yanking”？为什么", "是“查找和替换”的缩写？Vim的特性如此武断，不可能是被编造出来的，那么它们又从何而来呢？", "就像众多情况一样，答案是从那个古老的计算机熔炉——", "。从某种意义上说，Vim只是一款被称为“wq文本编辑器”软件的最新版本。自Unix时代诞生以来，这个软件一直在不断地被开发和改进。", "KenThompson创建了行编辑器", "1966年，贝尔实验室聘用了KenThompson。Thompson刚刚在加州大学伯克利分校完成了电气工程和计算机科学的硕士学位。在伯克利他使用一个名为QED的文本编辑器，该编辑器在1965到1966年间被开发用于伯克利分时系统。", "Thompson到达贝尔实验室后做的第一件事就是为麻省理工学院兼容分时系统重写QED。他后来又为Multics项目写了另一个版本的QED。在重写过程中，他对程序进行了扩展，以便用户可以在文件中搜索某一行，并使用正则表达式进行替换。", "与伯克利的分时系统一样，由麻省理工学院、通用电气和贝尔实验室合作的Multics项目试图创建一个可行的商业分时操作系统。最终，AT&T认为这个项目毫无进展并退出。在没有分时系统的情况下，Thompson和贝尔实验室资深研究员DennisRitchie，开始怀念分时系统所提供的“交互式计算的感觉”，并着手创建他们自己的版本，该版本最终发展成为Unix。", "1969年8月，在妻子和幼子外出去加州度假时，Thompson“给操作系统、shell、编辑器和汇编程序分别分配了一个星期”，将新系统的基本组件组合在一起。", "这个编辑器被称为", "。它是基于QED的，但并不完全是QED的复现。Thompson决定放弃某些QED的功能，弱化了对常规的表达式的支持，因此ed只能理解相对简单的正则表达式。QED允许用户打开多个缓冲区同时编辑多个文件，但是", "一次只使用一个缓冲区。QED可以执行包含命令的缓冲区，而", "则不能。这些简化可能是必要的。DennisRitchie曾说过，去掉QED的高级正则表达式是“并不大的损失”。", "现在是POSIX规范的一部分，所以如果你有一个符合POSIX的系统，你的电脑上就安装了", "。现在，许多", "命令都是Vim的一部分，因此，这就值得摆弄一番了。例如，你必须使用", "命令来写入磁盘缓冲区，必须使用", "命令来退出编辑器。这两个命令可以写在同一行命令中，也就是", "。", "与Vim一样，是一个模态编辑器；若要从命令模式进入输入模式，取决于你试图如何转换文本，需使用insert命令（", "）、append命令（", "）或change命令（", "）。", "还引入了", "语法来查找和替换或“替换”文本。", "考虑到所有这些相似之处，你可能会认为大部分Vim用户可以流畅地使用", "。但", "在另一个重要方面，和Vim一点也不相似。", "是一个真正的行编辑。它被广泛应用于电传打字机时代。当KenThompson和DennisRitchie在Unix上调试程序时看起来是这样的：", "不允许你编辑开放缓冲区中那些被其他行围绕的行，也不允许移动光标，因为", "在每次修改的时候都必须重新打印整个文件。在1969年，", "没有任何机制来“清除”屏幕上的内容，因为”屏幕“就是一张纸，所有已经输出的东西都像是已经用墨水打印出来了。在必要的时候，你可以使用列表命令（", "）要求", "打印出一系列的行，但是大多数时候，你都是在你看不到的文本上操作。因此，使用", "就像是尝试用一个低电量的手电筒在黑暗房间中摸索。每次你只能看到那么一点儿，所以必须尽最大努力去记住每件东西的位置。", "下面有一个", "会话的例子。我添加了注释（在字符", "之后）来解释了每一行，不过如果这些注释真的被输入，", "并不会把它们当作注释并且会报错：", "正如你所看到的，", "并不是一个特别友好的程序。", "BillJoy创建了文本编辑器", "对Thompson和Ritchie来说，", "已经足够好了。但是其他人则认为它很难用，而且它作为一个淋漓尽致地表现Unix对新手敌意的例子而臭名昭著。", "在1975年，一个名叫GeorgeCoulouris的人在伦敦玛丽皇后学院的Unix系统上开发了一个改进版", "。Coulouris利用他在玛丽女王学院的视频显示器开发他的编辑器。与", "不同的是，Coulouris的程序允许用户编辑在屏幕中的一行代码，通过一次次击键的方式来操作行（想象一下在Vim中每次编辑一行）。Thompson拜访玛丽女王学院时，看到Coulouris已经写好的程序，驳斥道他不需要在编辑文件的时候看到它的状态。受此启发，Coulouris将他的程序命名为", "，或者“为凡人而生的编辑器”。", "（", "）", "1976年，Coulouris把", "引入了加州大学伯克利分校，在那里他用了一个夏天的时间在CS系访学。这是KenThompson离开伯克利去贝尔实验室工作十年之后的事了。在伯克利，Coulouris遇到了BillJoy，一名伯克利软件发行公司（BSD）的研究生。Coulouris斯向Joy展示了", "，Joy以Coulouris的源代码为基础，为扩展", "建立了一个名为", "的改进版", "。1978年，1.1版本的", "与第1个版本的BSDUnix捆绑在一起。", "在很大程度上与", "兼容，但它增加了两种模式：一种“开放”模式，这种模式可以使", "单行编辑成为可能，还有一种“可见”模式，这种模式会占据整个屏幕，并且可以像我们今天所习惯的那样，对整个文件进行实时编辑。", "（", "）", "1979年的第2版BSD引入了一个名为", "的可执行文件，它只在可视模式下打开", "。", "/", "（后来称为", "）建立了我们现在使用的Vim中大多数的约定，但这些约定当时并不是", "的一部分。BillJoy使用的视频终端是LearSieglerADM-3A，它的键盘没有光标键。而是，", "上绘制光标键，所以BillJoy在", "中就使用这些键来进行光标移动。ADM-3A键盘上escape键位置是今天我们所使用的键盘上的tab键，这也就解释了为什么这样一个难以够着的键会被用来实现像退出当前模式这么常见的操作。前缀命令的", "字符同样也来自", "，它在常规模式下（即运行", "进入的模式）使用", "作为提示。这解决了一个", "中被长期诟病的问题，也就是一旦启动之后，没有任何反馈信息向用户致以问候。在可见模式下，保存和退出需要使用现在仍在使用的经典", "。“Yanking”和“puttng”、标记、以及用于设置选项的", "命令都是原始", "的一部分。我们今天在Vim中使用的的基本文本编辑过程，都是", "中使用的特性。", "是除", "之外唯一与BSDUnix捆绑的文本编辑器。在那个时候，Emacs可能会花费数百美元（这是在GNUEmacs之前），所以", "变得非常流行。但是", "是", "的直接衍生版本，这意味着如果没有AT&T的源代码，源代码就不能被修改。这促使一些人创建了", "的开源版本。STEVIE（专门为VI爱好者的ST编辑器）出现于1987年，Elvis出现于1990年，", "出现于1994年。其中一些克隆版本添加了额外的功能，如语法高亮和窗口分离。尤其是Elvis，它的许多功能被整合到Vim中，因为许多Elvis用户推动了这些功能的加入。", "BramMoolenaar创建了Vim", "“Vim”现在是“改进版Vi”的缩写，而最初代表的是“模拟版Vi”。和其他许多“vi克隆版本”一样，Vim始于在一个无法使用", "的平台上复现", "的一个尝试。在荷兰Venlo一家影印公司工作的软件工程师BramMoolenaar想要为他全新的Amiga2000准备一款类似于", "的编辑器。Moolenaar已经习惯了在大学时使用的Unix系统上的", "，当时他已经对", "了如指掌。", "所以在1988年，Moolenaar使用当时的STEVIE", "克隆版本开始在Vim上工作。", "（", "，2006年加入Google）", "Moolenaar接触到STEVIE缘于其曾经出现在一个叫FredFish的磁盘上。FredFish是一名美国程序员，每个月都会寄出一张软盘，内含为Amiga平台提供的精选可用开源软件。任何人只要支付邮费就可以得到一张这样的磁盘。有若干版本的STEVIE曾在FredFish磁盘上发布。Moolenaar使用的STEVIE版本在FredFish256号磁盘上发布。", "（令人失望的是，FredFish磁盘似乎与", "没有任何关系。）", "Moolenaar喜欢STEVIE，但很快就注意到其缺失了很多", "命令。", "因此，在第一次发布Vim时，Moolenaar优先考虑了", "的兼容性。当时已经有其他人编写了一系列的", "宏，当运行一个合适的", "兼容编辑器时，可以求解一个", "。Moolenaar能够让这些宏在Vim中运行。1991年，Vim以", "为名第一次发布于FredFish591号磁盘。", "Moolenaar添加了一些特性（包括多级撤销和解决编译器错误的“quickfix”模式），这意味着Vim已经完成了对", "的超越。在1993年通过FTP发布Vim2.0之前，Vim都仍以", "的身份存在。", "在众多互联网合作者的帮助下，Moolenaar稳健地在Vim中加入了一些功能。Vim2.0引入了对", "选项的支持，以及对长行文本进行水平滚动的支持。受到了", "克隆", "的启发，Vim3.0增加了对分割窗口和缓冲区的支持。Vim现在还将每个缓冲区保存到交换文件中以避免程序崩溃造成文件丢失。Vimscript支持语法高亮显示，第一次出现是在Vim5.0中。与此同时，Vim的受欢迎程度也在不断增长。它被移植到MS-DOS、Windows、Mac，甚至被移植到Unix与原来的", "竞争。", "2006年，Vim被", "读者评为最受欢迎的编辑器。", "如今，根据2018年StackOverflow的开发者调查，Vim是最受欢迎的文本模式（即终端模拟器）编辑器，受用于25.8%的软件开发人员(和40%的Sysadmin/DevOps人员)。", "在1980年代末和整个1990年代，程序员一度发起了“编辑器战争”，将Emacs用户与", "（即最终的Vim）用户进行了对比。虽然Emacs肯定仍有一些追随者，但有些人认为编辑器战争已经以Vim获胜而结束。", "2018年StackOverflow的开发者调查显示只有4.1%的受访者使用Emacs，也验证了这个事实。", "Vim是如何变得如此成功的？显然，人们喜欢Vim所提供的特性。但我认为，Vim背后的悠久历史表明了它的优势远不仅仅体现在其功能集上。Vim的代码库可以追溯到1988年，当时Moolenaar开始研究它。另一方面，“wq文本编辑器”——关于Unix-y文本编辑器应该如何工作的更广泛的愿景——可以追溯到半个世纪以前。“wq文本编辑器”有一些不同的具体表达方式，但在某种程度上要感谢BillJoy和BramMoolenaar对向后兼容性非比寻常的关注，才使好的想法逐渐积累起来。从这个意义上说，“wq文本编辑器”是运行时间最长、最成功的开源项目之一，得益于计算机世界中一些最伟大的思想贡献。我不认为“创业公司无视所有先例来创造颠覆性的新软件”的开发方式都是不妥的，但Vim提醒我们，这种协作和增量的方式同样能产生奇迹。", ""], "praise": 1, "collect": 2, "front_img_url": ["http://jbcdn2.b0.upaiyun.com/2012/04/vim-logo.png"]},{"artical_url": "http://blog.jobbole.com/114473/", "artical_url_md5": "d19d16854cc8aac90eb50785ce0e89f5", "title": "2018 年最好的 Linux 发行版", "add_time": "2018-10-28", "tag": "IT技术-Linux", "content": ["这是新的一年，Linux仍有无限可能。而且许多Linux发行版在2017年都带来了许多重大的改变，我相信在2018年它在服务器和桌面上将会带来更加稳定的系统和市场份额的增长。", "对于那些期待迁移到开源平台（或是那些想要切换到）的人对于即将到来的一年，什么是最好的选择？如果你去", "找一下，你可能会因为众多的发行版而感到头晕，其中一些的排名在上升，而还有一些则恰恰相反。", "因此，哪个Linux发行版将在2018年得到偏爱？我有我的看法。事实上，我现在就要和你们分享它。", "跟我做的", "相似，我将会打破那张清单，使任务更加轻松。普通的Linux用户，至少包含以下几个类别：系统管理员，轻量级发行版，桌面，为物联网和服务器发行的版本。", "根据这些，让我们开始2018年最好的Linux发行版清单吧。", "不常出现在“最好的”列表中。但它应该出现，为什么呢？如果了解到Ubuntu是基于Debian构建的（其实有很多的发行版都基于Debian），你就很容易理解为什么这个发行版应该在许多“最好”清单中。但为什么是对管理员最好的呢？我想这是由于两个非常重要的原因：", "因为Debain使用dpkg和apt包管理，它使得使用该环境非常简单。而且因为Debian提供了最稳定的Linux平台之一，它为许多事物提供了理想的环境：桌面、服务器、测试、开发。虽然Debian可能不包括去年本分类的优胜者", "所带有的大量应用程序，但添加完成任务所需的任何或全部必要的应用程序都非常容易。而且因为Debian可以根据你的选择安装不同的桌面（Cinnamon、GNOME、KDE、LXDE、Mate或者Xfce），肯定可以满足你对桌面的需求。", "同时，Debain在Distrowatch上名列第二。下载、安装，然后让它为你的工作而服务吧。Debain尽管不那么华丽，但是对于管理员的工作来说十分有用。", "轻量级的发行版有其特殊的用途：给予一些老旧或是性能低下的机器以新生。但是这不意味着这些特别的发行版仅仅只为了老旧的硬件机器而生。如果你想要的是运行速度，你可能会想知道在你的现代机器上这类发行版的运行速度能有多快。", "在2018年上榜的最轻量级的发行版是", "。尽管在这个类别里还有很多选择，而且尽管Lubuntu的资源占用与PuppyLinux一样小，但得益于它是Ubuntu家庭的一员，其易用性为它加了分。但是不要担心，Lubuntu对于硬件的要求并不高：", "Lubuntu使用的是LXDE桌面（图2），这意味着新接触Linux的用户在使用这个发行版时不会有任何问题。这份简短清单中包含的应用（例如：Abiword、Gnumeric和Firefox）都是非常轻量的，且对用户友好的。", "Lubuntu能让十年以上的电脑如获新生。", "连续两年都是我清单中最好的桌面发行版。对于许多人，", "（也是一个非常棒的分支）都是桌面发行版的领袖。但是，于我来说，它在易用性和稳定性上很难打败ElementaryOS。例如，我确信是", "17.10的发布让我迁移回了Canonical的发行版。迁移到新的使用GNOME桌面的Ubuntu不久之后，我发现我缺少了ElementaryOS外观、可用性和感觉（图3）。在使用Ubuntu两周以后，我又换回了ElementaryOS。", "使用ElementaryOS的任何一个人都会觉得宾至如归。Pantheon桌面是将操作顺滑和用户友好结合的最完美的桌面。每次更新，它都会变得更好。", "尽管ElementaryOS在Distrowatch页面访问量中排名第六，但我预计到2018年末，它将至少上升至第三名。Elementary开发人员非常关注用户的需求。他们倾听并且改进，这个发行版目前的状态是如此之好，似乎他们一切都可以做的更好。如果您需要一个具有出色可靠性和易用性的桌面，ElementaryOS就是你的发行版。", "很长一段时间内，", "都稳坐“展现你技能”的发行版的首座。但是，我认为现在Gentoo是时候让出“证明自己”的宝座给", "。你可能认为这不公平，因为LFS实际上不是一个发行版，而是一个帮助用户创建自己的Linux发行版的项目。但是，有什么能比你自己创建一个自己的发行版更能证明自己所学的Linux知识的呢？在LFS项目中，你可以从头开始构建自定义的Linux系统，而且是从源代码开始。所以，如果你真的想证明些什么，请下载", "并开始构建。", "已经是第二年赢得了该项的冠军。UbuntuCore是Ubuntu的一个小型的、事务型版本，专为嵌入式和物联网设备而构建。使UbuntuCore如此完美支持物联网的原因在于它将重点放在snap包上——这种通用包可以安装到一个平台上而不会干扰其基本系统。这些snap包包含它们运行所需的所有内容（包括依赖项），因此不必担心安装它会破坏操作系统（或任何其他已安装的软件）。此外，snap包非常容易升级，并运行在隔离的沙箱中，这使它们成为物联网的理想解决方案。", "UbuntuCore内置的另一个安全领域是登录机制。UbuntuCore使用UbuntuOnessh密钥，这样登录系统的唯一方法是通过上传的ssh密钥到", "（图4）。这为你的物联网设备提供了更高的安全性。", "这里有点意见不统一。主要原因是支持。如果你需要商业支持，乍一看，你最好的选择可能是", "。红帽年复一年地证明了自己不仅是全球最强大的企业服务器平台之一，而且是单一最赚钱的开源业务（年收入超过20亿美元）。", "但是，RedHat并不是唯一的服务器发行版。实际上，RedHat甚至并不能垄断企业服务器计算的各个方面。如果你关注亚马逊ElasticComputeCloud上的云统计数据，Ubuntu就会打败红帽企业Linux。根据", "的报告，EC2统计数据显示RHEL的部署率低于10万，而Ubuntu的部署量超过20万。", "最终的结果是，Ubuntu几乎已经成为云计算的领导者。如果你将它与Ubuntu对容器的易用性和可管理性结合起来，就会发现UbuntuServer是服务器类别的明显赢家。而且，如果你需要商业支持，Canonical将为你提供", "。", "对使用UbuntuServer的一个警告是它默认为纯文本界面（图5）。如果需要，你可以安装GUI，但使用UbuntuServer命令行非常简单（每个Linux管理员都应该知道）。", "正如我之前所说，这些选择都非常主观，但如果你正在寻找一个好的开始，那就试试这些发行版。每一个都可以用于非常特定的目的，并且比大多数做得更好。虽然你可能不同意我的个别选择，但你可能会同意Linux在每个方面都提供了惊人的可能性。并且，请继续关注下周更多“最佳发行版”选秀。", "通过Linux基金会和edX的免费", "课程了解有关Linux的更多信息。", ""], "praise": 2, "collect": 2, "front_img_url": ["http://jbcdn2.b0.upaiyun.com/2018/10/22b50c4f6378466a0259ad8ceeedd1ed.jpg"]},{"artical_url": "http://blog.jobbole.com/114466/", "artical_url_md5": "66d853efc56bcb1bdc594f4a6e4f1542", "title": "人人都能读懂的编译器原理", "add_time": "2018-11-01", "tag": "IT技术-编译器", "content": ["理解编译器内部原理，可以让你更高效利用它。按照编译的工作顺序，逐步深入编程语言和编译器是怎样工作的。本文有大量的链接、样例代码和图表帮助你理解编译器。", "作者注：", "这是我在Medium上的第二篇文章的再版，", "有超过21000的阅读量。很高兴我能够帮助到各位的学习，", "我选择Rust作为这篇文章的主要语言。它是一种详尽的、高效的、现代的而且看起来特意使得设计编译器变得简单。我很喜欢使用它。", "写这篇文章的目的主要是吸引读者的注意力，而不是提供20多页的令人头皮发麻的阅读材料。对于那些你感兴趣的更深层次的话题，文章中有许多链接会引导你找到相关的资料。大多数链接到维基百科。", "感谢你的关注，我希望你能够喜欢这些我花费了超过20个小时的写出的文章。欢迎在文章底部评论处留下任何问题或者建议。", "简单介绍", "编译器的语言部分就是它处理的文本样式。因为电脑只能读取1和0，而人们编写Rust程序要比直接编写二进制程序简单地多，因此编译器就被用来把人类可读的文本转换成计算机可识别的机器码。", "编译器可以是任何可以把文本文件转换成其他文件的程序。例如，下面有一个用Rust语言写的编译器把0转换成1，把1转换成0：", "简言之，编译器获取源代码，产生一个二进制文件。因为从复杂的、人类可读的代码直接转化成0/1二进制会很复杂，所以编译器在产生可运行程序之前有多个步骤：", "尽管我说编译器直接从表达式树转换到二进制，但实际上它会产生汇编代码，之后汇编代码会被汇编/编译到二进制数据。汇编程序就好比是一种高级的、人类可读的二进制。更多关于汇编语言的阅读资料在", "。", "非常像编译器，它也是读入编程语言的代码，然后处理这些代码。尽管如此，", "解释器最大的优点就在于在你debug期间运行程序所消耗的时间。编译器编译一个程序可能在一秒到几分钟不等，然而解释器可以立即开始执行程序，而不必编译。解释器最大的缺点在于它必须安装在用户电脑上，程序才可以执行。", "虽然这篇文章主要是关于编译器的，但是对于编译器和解释器之间的区别和编译器相关的内容一定要弄清楚。", "1.词法分析", "第一步是把输入一个词一个词的拆分开。这一步被叫做", ",或者说是分词。这一步的关键就在于", "词法分析大多都不需要处理逻辑运算像是算出", "–其实这个表达式只有三种", "：一个数字：", ",一个加号，另外一个数字：", "。", "让我们假设你正在解析一个像是", "这样的字符串：它会读入字符", "，", "，", "，和", "。我们已经把这些字符拆分开了，但是现在我们必须把他们组合起来；这是分词器的主要任务之一。举个例子，我们得到了两个单独的字符", "和", "，但是我们需要把它们放到一起，然后把它们解析成为一个整数。至于", "也需要被识别为加号，而不是它的字符值–字符值是43。", "如果你可以阅读过上面的代码，并且弄懂了这样做的含义，接下来的Rust分词器会组合数字为32位整数，加号就最后了标记值Plus（加）.", "在一种编程语言的编译器中，词法解析器可能需要许多不同类型的标记。例如：符号，数字，标识符，字符串，操作符等。想知道要从源文件中提取怎样的标记完全取决于编程语言本身。", "2.解析", "解析器确实是语法解析的核心。", "解析器逐词地定义编程语言的语法。", "和", "的区别在于解析器的处理上面。解析器决定了语法的外在形式是怎样的。它确保括号和花括号的左右括号是数量平衡的，每个语句结尾都有一个分号，每个函数都有一个名称。当标记不符合预期的模式时，解析器就会知道标记的顺序不正确。", "你可以写好几种不同", "。最常见的解析器之一是从上到下的，", "。递归降解的解析器是用起来最简单也是最容易理解的解析器。我写的所有解析器样例都是基于递归降解的。", "解析器解析的语法可以使用一种", "表示出来。像", "这样的语法就可以描述一个解析器用于解析简单的数学运算，像是这样", ":", "那种语法的解析器应该是", "解析器，因为它直接与所有内容都相关的顶层。唯一有效的输入必须是任意数字，加号或减号，任意数字。", "需要一个", ",这主要出现在加法和减法表达式中。", "首先需要一个", "（一个数字），然后是加号或者减号，最后是另一个", "。", "", "我之前补充了我们的词法分析器代码，以便它与我们的语法想匹配，并且可以产生像图表一样的AST。我用", "和", "的注释标记出了新的解析器代码的开头和结尾。", "我们可以再深入一点。假设我们想要支持只有数字没有运算符的输入，或者添加除法和乘法，甚至添加优先级。只要简单地修改一下语法文件，这些都是完全有可能的，任何调整都会直接反映在我们的解析器代码中。", "", "3.生成代码", "接收一个AST,然后生成相应的代码或者汇编代码。代码生成器必须以递归下降的顺序遍历AST中的所有内容-就像是解析器的工作方式一样-之后生成相应的内容，只不过这里生成的不再是语法树，而是代码了。", "如果打开上面的链接，你就可以看到左侧样例代码产生的汇编代码。汇编代码的第三行和第四行展示了编译器在AST中遇到常量的时候是怎样为这些常量生成相应的代码的。", "GodboltCompilerExplorer是一个很棒的工具，允许你用高级语言编写代码，并查看它产生的汇编代码。你可以有点晕头转向了，想知道产生的是哪种代码，但不要忘记给你的编程语言编译器添加优化选项来看看它到底有多智能。（对于Rust是", "）", "如果你对于编译器是在汇编语言中怎样把一个本地变量保存到内存中感兴趣的话，", "（“代码生成”部分）非常详细地解释了堆栈的相关知识。大多数情况下，当变量不是本地变量的时候，高级编译器会在堆区为变量分配空间，并把它们保存到堆区，而不是栈区。你可以从", "阅读更多关于变量存储的内容。", "因为汇编是一个完全不同的，而且复杂的主题，因此这里我不会过多地讨论它。我只是想强调代码生成器的重要性和它的作用。此外，代码生成器不仅可以产生汇编代码。", "编译器有一个可以产生6种以上不同的编程语言的", "：包括C++,Java,和Python。", "后端指的是编译器的代码生成器或者表达式解析器；因此前端是词法分析器和解析器。同样也有一个中间端，它通常与优化和IR有关，这部分会在稍后解释。后端通常与前端无关，后端只关心它接收到的AST。这意味着可以为几种不同的前端或者语言重用相同的后端。大名鼎鼎的", "就属于这种情况。", "我找不到比我的C编译器后端更好的代码生成器示例了；你可以在", "查看。", "在生成汇编代码之后，这些汇编代码会被写入到一个新的汇编文件中(", "或", ")。然后该文件会被传递给汇编器，汇编器是汇编语言的编译器，它会生成相应的二进制代码。之后这些二进制代码会被写入到一个新的目标文件中(", ")。", "为了让它们变成可执行文件，目标文件需要被链接到一起。链接器读取通用的机器码，然后使它变为一个可执行文件、", "或是", "。更多关于链接器的知识在", "。", "链接器是因操作系统而不同的应用程序。随便一个第三方的链接器都应该可以编译你后端产生的目标代码。因此在写编译器的时候不需要创建你自己的链接器。", "编译器可能有", ",或者简称IR。", "IR不再是原来的代码；IR是为了寻找代码中潜在的优化而进行的无损简化。", "和", "都是利用IR完成的。更多关于IR相关的优化可以在这个", "中找到。", "总结", "当你理解了编译器的时候，你就可以更有效地使用你的编程语言。或许有一天你会对创建你自己的编程语言感兴趣？我希望这能够帮到你。"], "praise": 3, "collect": 3, "front_img_url": ["http://wx1.sinaimg.cn/mw690/7cc829d3ly1fwjgiwii9lj20qn0gqdgl.jpg"]}